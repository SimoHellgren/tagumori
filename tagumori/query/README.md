# query

Parses and executes tag queries against the database.

## Pipeline

```
string --> parser --> parse tree --> AST --> query plan --> SQL results
```

1. **parser.py** - Standalone LALR(1) parser generated by Lark from `grammar.lark`. Do not edit by hand.
2. **ast.py** - `Transformer` converts the parse tree into a typed AST (`Tag`, `And`, `Or`, `Not`, etc.).
3. **planner.py** - `to_query_plan` lowers the AST into a query plan (`TagPath`, `QP_And`, `QP_Or`, etc.) and `simplify` normalizes it (flattening, double-negation elimination, single-operand unwrapping).
4. **executor.py** - Translates the query plan into recursive CTEs and runs them against SQLite.

## Regenerating the parser

When `grammar.lark` changes, regenerate `parser.py`:

```
python -m lark.tools.standalone tagumori/query/grammar.lark > tagumori/query/parser.py
```

## Query syntax

| Syntax | Meaning |
|--------|---------|
| `name` | Tag exists |
| `name[E]` | Tag with children matching E |
| `a,b` | AND |
| `a\|b` | OR |
| `a^b` | XOR (true when odd number match) |
| `xor(a,b,c)` | Exactly one of |
| `!a` | NOT |
| `~` | Null (root outside brackets, leaf inside) |
| `*` | Any single tag |
| `**` | Any path (not yet implemented) |
| `*n*` | At most n tags deep (not yet implemented) |
| `(E)` | Grouping |

Operator precedence (highest first): `!`, `,`, `|`, `^`.

For distribution laws, negation semantics, wildcard identities, and simplification rules, see [algebra.md](algebra.md).
